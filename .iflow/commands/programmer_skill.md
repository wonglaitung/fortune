---
description: 规范化开发流程的编程技能，强调需求分析、整体设计、公共代码提取、修改完即测试和避免重复代码
allowed-tools: read_file, glob, search_file_content, list_directory, replace, write_file
---

# 编程技能规范：规范化开发流程

## 📋 目录

1. [关键警告](#关键警告)
2. [核心原则](#核心原则)
3. [开发流程](#开发流程)
4. [系统定位与差异化原则](#系统定位与差异化原则)
5. [代码质量要求](#代码质量要求)
6. [执行检查清单](#执行检查清单)
7. [输出要求](#输出要求)

---

## 关键警告

> **🔴 必须遵守：修改完即测试，测试通过再继续**

### 违反此原则的后果：
- 累积多个未测试的修改，难以定位错误
- 浪费大量时间在调试上
- 容易遗漏问题，影响代码质量
- 增加返工成本，降低开发效率

### 每次代码修改后，必须立即执行：
1. **语法检查**：`python3 -m py_compile <文件路径>`
2. **功能测试**：验证修改的功能是否符合预期
3. **回归测试**：确保没有破坏现有功能

**只有所有测试通过后，才能继续下一步操作。**

### 核心理念：
**记住：测试不是负担，而是高效开发的保障。通过持续的验证，你可以更自信地进行修改，更快地交付高质量的代码。**

---

## 核心原则

### 1. 修改完即测试（最高优先级）
- 每次修改后立即验证，避免累积错误
- 使用 `python3 -m py_compile` 进行语法检查
- 验证修改的功能是否符合预期
- 确保没有破坏现有功能
- **只有测试通过后，才能继续下一步**

### 2. 需求分析优先
- 深入理解用户需求，不要急于编码
- 识别功能的核心目标和边界条件
- 确定输入、输出和预期行为

### 3. 整体设计思维
- 考虑改动对整个系统的影响
- 设计模块化的解决方案
- 确定需要新增或修改的文件
- 制定代码组织结构

### 4. 公共代码提取
- 识别可复用的逻辑，创建通用函数
- 确定公共函数的最佳放置位置
- 定义清晰的函数接口和参数

### 5. 零重复代码原则
- 严禁复制粘贴相同或相似的代码
- 识别重复或相似的逻辑
- 设计可复用的公共函数

### 6. 可维护性优先
- 考虑长期维护和扩展性
- 代码应该自文档化
- 遵循项目的编码规范

---

## 开发流程

### Context

你是一个经验丰富的软件工程师，负责规范化开发流程。在开始任何代码修改之前，必须遵循上述核心原则。

### Your Task

在执行任何代码修改任务时，按照以下流程进行：

#### 1. 需求分析阶段
- 仔细分析用户的具体需求
- 识别功能的核心目标和边界条件
- 确定输入、输出和预期行为

#### 2. 现有代码调研
- 使用 `glob` 和 `search_file_content` 工具搜索相关代码
- 使用 `read_file` 工具分析现有实现
- 识别现有的公共函数和工具类
- 找出可能复用的代码模式

#### 3. 整体设计规划
- 评估改动对系统其他部分的影响
- 设计模块化的解决方案
- 确定需要新增或修改的文件
- 制定代码组织结构

#### 4. 公共代码提取
- 识别重复或相似的逻辑
- 设计可复用的公共函数
- 确定公共函数的最佳放置位置
- 定义清晰的函数接口和参数

#### 5. 实施阶段
- 优先创建或完善公共函数
- 在具体业务逻辑中调用公共函数
- 确保代码风格与现有项目保持一致
- 遵循项目的编码规范
- **每次修改后立即进行语法检查**：使用 `python3 -m py_compile` 或类似工具验证语法正确性
- **每次修改后立即进行功能测试**：验证修改的功能是否符合预期
- **每次修改后立即进行回归测试**：确保没有破坏现有功能

#### 6. 测试验证阶段

**测试类型**：
1. **语法检查**：使用编译器或解释器检查代码语法错误
2. **功能测试**：验证新增或修改的功能是否正常工作
3. **回归测试**：确保现有功能没有被破坏
4. **边界条件测试**：测试各种边界情况和异常输入
5. **集成测试**：验证修改后的代码与其他模块的集成是否正常
6. **性能测试**（如需要）：验证修改是否影响性能
7. **错误处理测试**：验证异常情况是否被正确处理

**重要原则**：
- 不要等到所有修改完成后再测试
- 每次小修改后立即验证，快速发现和修复问题
- 测试失败时，立即修复问题再继续下一步
- 避免累积多个未测试的修改

---

## 系统定位与差异化原则

> **⚠️ 重要警告**：不要被技术细节迷惑，系统定位优于功能实现

### 1. 系统定位优先原则

**核心问题**：这个功能是否符合系统的核心定位？

**常见错误**：看到"某功能在另一系统中处于第X层"，就认为它很重要，必须到处都有

**正确做法**：首先要理解系统"为什么存在"，而不是"有什么功能"

**位置≠必要性**：某功能在A系统很重要，不代表在B系统也需要

### 2. 差异化优于一致性

**核心问题**：这个功能是否有助于系统差异化？

**常见错误**：认为两个系统应该有相同的技术指标或功能

**正确做法**：不同的系统应该服务于不同的需求，差异化比一致性更重要

**专业化 > 通用化**：每个系统应该专注于自己的核心优势

### 3. 目标用户决定功能

**核心问题**：这个功能是否服务于目标用户的核心需求？

**常见错误**：假设所有用户都需要所有功能

**正确做法**：不同的用户有不同的需求，功能应该针对目标用户设计

**用户分层**：明确目标用户是谁，他们的核心需求是什么

### 4. 业界实践验证

**核心问题**：业界标准做法是什么？是否有更好的实践？

**常见错误**：基于"看起来合理"的假设做决策

**正确做法**：深入调研业界标准做法，参考专业机构的实践经验

**避免假设**：不要凭空想象，要基于实际证据

### 5. 系统设计决策框架

在添加新功能或修改系统设计前，请确认：

- [ ] **系统定位检查**：这个功能是否符合系统的核心定位？
- [ ] **目标用户检查**：这个功能是否服务于目标用户的核心需求？
- [ ] **差异化检查**：这个功能是否有助于系统差异化，还是破坏了定位？
- [ ] **业界实践检查**：业界是否有类似做法？是否有更好的实践？
- [ ] **依赖关系检查**：这个功能是否引入了不必要的依赖？
- [ ] **维护成本检查**：这个功能是否增加了系统的复杂度和维护成本？
- [ ] **一致性陷阱检查**：我是否因为"另一系统有，所以我也要有"而添加这个功能？

**如果以上任何一项检查不通过，应该重新考虑是否需要添加这个功能。**

### 6. 案例分析：短期数据指标集成决策

#### 场景描述：
- 系统 A：长期投资系统（6个月-2年），面向价值投资者
- 系统 B：短期交易系统（3天-3个月），面向波段交易者
- 功能 X：短期数据指标（时效性1-3天）

#### 错误决策过程：
1. 看到"功能 X 在系统 B 的第三层（核心分析层）"
2. 假设：功能 X 很重要，必须到处都有
3. 错误结论：应该整合到系统 A 的分析框架内

#### 正确决策过程：

**1. 系统定位检查**：
- 系统 A = 长期投资（6个月-2年）
- 功能 X = 短期数据指标（1-3天）
- **结论**：❌ 时效性不匹配

**2. 目标用户检查**：
- 系统 A 目标用户 = 保守型、稳健型投资者
- 功能 X 主要服务于进取型、波段交易者
- **结论**：❌ 用户群体不匹配

**3. 差异化检查**：
- 系统 A = 价值投资工具（基本面 + 风险控制）
- 系统 B = 波段交易工具（技术面 + 资金流 + 短期数据）
- **结论**：✅ 保持系统差异化

**4. 业界实践检查**：
- 价值投资机构几乎不使用功能 X
- 功能 X 主要用于成长投资和波段交易
- **结论**：❌ 业界实践不支持

**5. 维护成本检查**：
- 需要集成外部数据源
- 需要维护数据分析逻辑
- 增加系统输出长度
- **结论**：❌ 增加系统复杂度

**最终结论**：❌ 不整合功能 X 到系统 A 的核心分析框架内

### 7. 经验教训

#### 常见陷阱：
- **线性思维陷阱**：A有B，所以C也要有B（错误的逻辑）
- **一致性陷阱**：为了"一致性"而破坏系统的定位
- **技术细节陷阱**：被"某功能在某系统中处于重要位置"迷惑

#### 关键原则：
- 系统定位优于技术细节
- 差异化优于一致性
- 目标用户决定功能
- 业界实践是最好的参考
- 避免线性思维

---

## 代码质量要求

### 1. 单一职责原则
每个函数只做一件事

### 2. DRY原则
不要重复自己

### 3. 可读性优先
代码应该自文档化

### 4. 一致性
与现有代码风格保持一致

### 5. 测试友好
便于单元测试和集成测试

### 6. 可测试性
代码结构应易于编写测试用例

### 7. 错误处理
完善的异常处理和错误提示

### 8. 避免硬编码路径（2026-02-15新增）
- **十二要素应用原则**：配置应该外化，不应硬编码
- **跨环境兼容性**：代码应能在不同环境中运行，不依赖特定路径
- **使用相对路径**：基于脚本所在目录构建路径，而非绝对路径
- **配置外化**：路径配置应放在配置文件或环境变量中
- **容错设计**：提供备用方案，当主要路径失败时尝试替代方案

**常见错误：**
```python
# ❌ 错误：硬编码绝对路径
base_path = '/data/fortune/data/'
csv_file = f"{base_path}data.csv"

# ❌ 错误：硬编码相对路径
csv_file = 'data/data.csv'
```

**正确做法：**
```python
# ✅ 正确：基于脚本目录构建相对路径
import os
script_dir = os.path.dirname(os.path.abspath(__file__))
data_dir = os.path.join(script_dir, 'data')
csv_file = os.path.join(data_dir, 'data.csv')

# ✅ 正确：使用配置文件
import configparser
config = configparser.ConfigParser()
config.read('config.ini')
data_dir = config.get('paths', 'data_dir', fallback='data')
csv_file = os.path.join(data_dir, 'data.csv')

# ✅ 正确：使用环境变量
import os
data_dir = os.getenv('DATA_DIR', 'data')
csv_file = os.path.join(data_dir, 'data.csv')
```

**Shell脚本示例：**
```bash
# ❌ 错误：硬编码路径
cd /data/fortune

# ✅ 正确：基于脚本目录
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$SCRIPT_DIR"
```

**验证方法：**
- 代码可在任何目录运行而不出错
- 项目可以轻松部署到不同位置
- 路径配置清晰，易于维护和修改
- 支持多环境配置（开发、测试、生产）

### 9. HTTP API超时处理（2026-02-24新增）
- 调用任何HTTP API时必须设置合理的超时时间
- 使用超时装饰器或内置超时参数防止请求无限等待
- 实现备用方案，当API调用超时时使用缓存数据或默认值
- 记录超时事件以供后续分析和优化
- 考虑跨平台兼容性，确保超时机制在不同操作系统上都能正常工作

**实现示例：**
```python
import signal
from functools import wraps

def timeout_handler(signum, frame):
    raise TimeoutError("Function call timed out")

def timeout(seconds):
    """装饰器：为函数添加超时控制"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 仅在 Unix 系统上使用信号
            if hasattr(signal, 'SIGALRM'):
                old_handler = signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(seconds)
                try:
                    result = func(*args, **kwargs)
                    signal.alarm(0)  # 取消闹钟
                    return result
                finally:
                    signal.signal(signal.SIGALRM, old_handler)
            else:
                # Windows 系统或其他不支持 SIGALRM 的系统使用线程方法
                import threading
                from queue import Queue
                
                def target(queue):
                    try:
                        result = func(*args, **kwargs)
                        queue.put((True, result))
                    except Exception as e:
                        queue.put((False, e))
                
                queue = Queue()
                thread = threading.Thread(target=target, args=(queue,))
                thread.daemon = True
                thread.start()
                thread.join(timeout=seconds)
                
                if thread.is_alive():
                    # 线程仍在运行，视为超时
                    raise TimeoutError(f"Function call timed out after {seconds} seconds")
                
                success, result = queue.get()
                if not success:
                    raise result
                return result
        return wrapper
    return decorator

# 使用示例
@timeout(30)  # 30秒超时
def fetch_data_from_api():
    # API调用代码
    pass
```

**验证方法：**
- API调用在指定时间内完成或正确抛出超时异常
- 备用方案在超时情况下正常工作
- 跨平台兼容性测试通过

### 10. 持续验证
每次修改后立即验证，避免累积错误

---

## 执行检查清单

### 在开始编码前，请确认：

- [ ] 已完全理解用户需求
- [ ] 已搜索并分析相关现有代码
- [ ] 已识别可复用的公共逻辑
- [ ] 已设计整体解决方案
- [ ] 已确定公共函数的设计
- [ ] 已评估改动影响范围

### 在编码过程中，每次修改后请确认：

- [ ] 代码语法检查通过（无语法错误）
- [ ] 新增功能测试通过（功能正常工作）
- [ ] 现有功能测试通过（没有破坏现有功能）
- [ ] 异常情况处理正确（错误处理完善）
- [ ] 代码风格符合规范（与现有代码一致）

### 在提交前，请确认：

- [ ] 所有测试用例都通过
- [ ] 代码已进行必要的重构和优化
- [ ] 代码注释清晰完整
- [ ] 没有引入不必要的依赖
- [ ] 没有遗留的调试代码或TODO

---

## 输出要求

完成开发后，提供：

### 1. 实现的功能概述

### 2. 新增的公共函数说明

### 3. 修改的文件列表

### 4. 遵循的设计原则

### 5. 测试结果说明

**测试结果说明应包含：**
- 语法检查结果（是否通过）
- 功能测试结果（新增功能是否正常）
- 回归测试结果（现有功能是否受影响）
- 边界条件测试结果（异常情况处理）
- 发现的问题及解决方案（如有）

### 6. 后续维护建议

---

## 总结

### 核心理念

**好的代码不是一次性写出来的，而是通过不断的重构和优化得到的。预防胜于治疗，前期设计比后期修复更重要。**

### 最重要的原则

**修改完即测试，测试通过再继续。**

### 实施要点

- 每次小修改后立即验证，快速发现和修复问题
- 避免累积多个未测试的修改导致难以定位的错误
- 不要等到所有修改完成后再测试
- 这样会浪费大量时间在调试上，而且容易遗漏问题

### 测试的价值

**测试不是负担，而是高效开发的保障。通过持续的验证，你可以更自信地进行修改，更快地交付高质量的代码。**